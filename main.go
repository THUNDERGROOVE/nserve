// nginx-serve is a utility for hosting multiple applications using a reverse proxy with nginx
// Based on configuration in /etc/nserve/* we generate files in /etc/nginx/sites-enabled/*
package main

import (
	"encoding/json"
	. "github.com/THUNDERGROOVE/nserve/lib"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

// TODO: Load files from /etc/nserve/*
// TODO: Generate nginx configuration files
// TODO: Start processes
// TODO: Monitor processes
// TODO: API to check the status of running processes
// TODO: Frontend for said API
// TODO: Helper commands.  1) Create new target
// TODO: Github API to automatically pull & build
// TODO: No more json

var nginxtempl = `
# Automatically generated by nserve

server {
	listen 80;
	listen [::]:80;
	server_name {{.ServerName}};
	location {{.Location}} {
		proxy_pass http://127.0.0.1:{{.Port}};
	}
}
`

var nt = template.New("")

func main() {
	var err error
	nt, err = nt.Parse(nginxtempl)
	if err != nil {
		log.Fatal(err)
	}
	targets := CollectTargets()

	for _, v := range targets {
		GenerateConfig(*v)
		go HandleTarget(v)
	}

	cmd := exec.Command("nginx", "-s", "reload")
	err = cmd.Run()
	if err != nil {
		log.Fatalf("Couldn't reload nginx config %s\n", err.Error())
	}

	http.HandleFunc("/", func(rw http.ResponseWriter, req *http.Request) {
		enc := json.NewEncoder(rw)
		enc.Encode(targets)
	})

	http.ListenAndServe(":5598", nil)
}

func GenerateConfig(t Target) {
	if t.NoNginx {
		return
	}
	if t.ServerName == "" {
		t.ServerName = "localhost"
	}
	if t.Location == "" {
		t.Location = "/"
	}
	if t.Port == "" {
		log.Printf("Port must be set when generating an nginx config.  Skipping for target %s", t.Name)
		return
	}

	filename := filepath.Join("/etc/nginx/conf.d", t.Name+".conf")

	log.Printf("Generating %s for target %s", filename, t.Name)

	f, err := os.Create(filename)
	defer f.Close()
	if f == nil {
		log.Printf("Failed to create config file for target %s: %s\n", t.Name, err.Error())
		return
	}

	err = nt.Execute(f, t)
	if err != nil {
		log.Printf("Error executing template: %s\n", err.Error())
	}
}

func StartTarget(t *Target) {
	t.Data.Started = time.Now()
	log.Printf("(re)Starting target %s", t.Name)
	cmd := exec.Command(t.Command, t.Arguments...)
	if strings.Contains(t.Command, "/") {
		dir, _ := filepath.Split(t.Command)
		cmd.Dir = dir
	}
	t.Running = true
	err := cmd.Run()
	t.Running = false
	if err != nil {
		log.Printf("Failed to start target %s", t.Name)
	}
}

func HandleTarget(t *Target) {
	StartTarget(t)
	for {
		log.Printf("Target %s unexpectedly stopped.  Maybe retrying?", t.Name)
		if time.Since(t.Data.Started) > time.Second*30 {
			StartTarget(t)
		} else {
			log.Printf("Not yet.  Last restart was %s ago", time.Since(t.Data.Started).String())
			time.Sleep(15 * time.Second)
		}
	}
}

func CollectTargets() []*Target {
	var targets []*Target
	files, err := ioutil.ReadDir("/etc/nserve")
	if err != nil {
		log.Fatalf("Failed to read files in /etc/nserve: %s\n", err.Error())
	}

	for _, f := range files {
		var filename string
		filename = filepath.Join("/etc", "nserve", f.Name())

		if f.IsDir() {
			continue
		}
		data, err := ioutil.ReadFile(filename)
		if err != nil {
			log.Printf("Failed to read target file %s: %s", filename, err.Error())
			continue
		}

		var t Target
		err = json.Unmarshal(data, &t)
		if err != nil {
			log.Printf("Failed to parse target file %s: %s", filename, err.Error())
			continue
		}

		if t.Name == "" {
			t.Name = f.Name()
		}

		log.Printf("Sucessfully parsed target %s\n", t.Name)

		targets = append(targets, &t)
	}

	return targets
}
